*** Docker 
*** ------

→ Docker provides 'consistency' across multiple environments and operating systems.
→ Two major concepts in Docker :

^ 1. Images :
    - Image is like a class or a recipe of a dish. It is a blueprint for containers.
    - Built from a Dockerfile.
^ 2. Containers :
    - Containers is like an object, a runnable instance of image.
    - We can run multiple containers from single imaage.

More...

^ 3. Dockerfile :
    - Instruction to build a docker image.
^ 4. Docker Hub/Registery :
    - Store and share images.
    - DockerHub for Docker is like GitHub for Git.
^ 5. Volumes :
    - Persistent data storage for containers.
^ 6. Networks :
    - Communication between containers.


* DOCKERFILE : (Example)
* ______________________

FROM node
LABEL maintainer='rinkal singapuri'
LABEL version='1.0'
ENV port=3000

WORKDIR / app
COPY package*.json ./
RUN npm install
COPY . .

EXPOSE 8298
CMD ["npm", "run", "dev"]

^ Explanation :

    1. FROM :
        → It specifies the base image.
        → basically how the image built (here, from node)
    
    2. LABEL :
        → Information about the image like who's the maintainer, what's the version.

    3. ENV :
        → Sets environment variables.

    4. WORKDIR :
        → It create 'app' folder inside the container.
        → WORKDIR / app doesn't mean that we should have the main directory named as app, but it will build app directory in the container where all the code goes from here.
        → It means that inside the container, work inside /app.

    5. COPY package*.json ./ :
        → It will copy package.json and package-lock.json from the current directory.

    6. RUN npm install :
        → Install dependencies into /app/node_modules

    7. COPY . . :
        → Copy rest of the all code.

    8. EXPOSE :
        → port number. (just for the documentation)

    9. CMD :
        → run commands.


* COMMANDS 
* ________

1. docker run -t <image_name>
    → To craete an image

2. docker run -p <port_number>:<port_number> <image_name> :
    → To run docker image

    → first port number is for host machine, and second is for container.
    → port number is specified twice because container has its own isolated network. App inside the container might run on 5173, but the host machine(your laptop) also need to know where to forward requests. 

3. docker run -p 5173:5173 -v "$(pwd):/app" -e CHOKIDAR_USEPOLLING=true <docker_image_name> :
    To dynamically run image meaning new changes will reflect on the page.

3. docker rename <old_container_name> <new_container_name> :
    → To rename a docker container
    
4. docker stop <first_three_digits_of_container_ID> :
    → To stop a container from running

5. docker container prune :
    → To delete all stopped containers

6. docker ps :
    → To see all 'active' containers

7. docker ps -a :
    → To see all containers

8. docker rm <first_three_digits_of_container_ID> :
    → To remove a specific 'stopped' container

9. docker rm <first_three_digits_of_container_ID> --force :
    → To remove a specific 'active' container

^ Note : Always specify port number as '5173' while creating 'react' image.

* DOCKER-COMPOSE
* ______________

→ Docker compose allows you to run multicontainer applications in just one go using 'docker compose up' command on terminal.
→ it is written in YMAL file.

^ Example:

For running the frontend dynamically meaning new changes will reflect on the page.

services:
  web:
    build: 
      context: .
      dockerfile: Dockerfile
    working_dir: /app
    volumes:
      - .:/app
    ports:
      - 5173:5173
    environment:
      - CHOKIDAR_USEPOLLING=true
    command: sh -c "npm install && npm run dev"

here in 'command', 
    → sh -c means start a shell inside container to run quoted string, basically useful when && like conditions are specified.
    → np  install will install dependencies
    → && ensures 'npm run dev' executes only after 'npm install' completes successfully.
    → 'npm run dev' will run the page.
